{"ast":null,"code":"\"use strict\";\n\n// @flow strict\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst react_1 = require(\"react\");\nconst events_1 = require(\"./helpers/events\");\nconst find_1 = __importDefault(require(\"./helpers/find\"));\nconst getClosestTransformedParent_1 = __importDefault(require(\"./helpers/getClosestTransformedParent\"));\nconst rect_1 = require(\"./helpers/rect\");\nconst buildTopStyles = (container, props) => {\n  const {\n    bottomOffset,\n    hideOnBoundaryHit\n  } = props;\n  const {\n    top,\n    height,\n    width,\n    boundaryBottom\n  } = container;\n  // above boundary\n  if (hideOnBoundaryHit || top + height + bottomOffset < boundaryBottom) {\n    return {\n      top: `${top}px`,\n      width: `${width}px`,\n      position: 'fixed'\n    };\n  }\n  // reaching boundary\n  if (!hideOnBoundaryHit && boundaryBottom > 0) {\n    return {\n      top: `${boundaryBottom - height - bottomOffset}px`,\n      width: `${width}px`,\n      position: 'fixed'\n    };\n  }\n  // below boundary\n  return {\n    width: `${width}px`,\n    bottom: `${bottomOffset}px`,\n    position: 'absolute'\n  };\n};\nconst buildBottomStyles = (container, props) => {\n  const {\n    bottomOffset,\n    hideOnBoundaryHit\n  } = props;\n  const {\n    bottom,\n    height,\n    width,\n    boundaryTop\n  } = container;\n  if (hideOnBoundaryHit || bottom - height - bottomOffset > boundaryTop) {\n    return {\n      width: `${width}px`,\n      top: `${bottom - height}px`,\n      position: 'fixed'\n    };\n  }\n  return {\n    width: `${width}px`,\n    top: `${bottomOffset}px`,\n    position: 'absolute'\n  };\n};\nconst buildStickyStyle = (mode, props, container) => (mode === 'top' ? buildTopStyles : buildBottomStyles)(container, props);\nconst isEqual = (obj1, obj2) => {\n  const styles1 = obj1.wrapperStyles;\n  const styles2 = obj2.wrapperStyles;\n  if (obj1.isFixed !== obj2.isFixed || obj1.height !== obj2.height || !styles1 && styles2 || styles1 && !styles2) {\n    return false;\n  }\n  if (!styles2) {\n    return true;\n  }\n  for (const field in styles1) {\n    // @ts-expect-error - ts doesn't like that `field` is a string\n    // eslint-disable-next-line no-prototype-builtins\n    if (styles1.hasOwnProperty(field) && styles1[field] !== styles2[field]) {\n      return false;\n    }\n  }\n  return true;\n};\nclass Sticky extends react_1.Component {\n  constructor() {\n    super(...arguments);\n    this.holderEl = null;\n    this.wrapperEl = null;\n    this.el = null;\n    this.scrollEl = null;\n    this.boundaryEl = null;\n    this.disabled = false;\n    this.checkPositionIntervalId = null;\n    this.lastMinHeight = null;\n    this.state = {\n      isFixed: false,\n      wrapperStyles: undefined,\n      holderStyles: undefined,\n      height: 0\n    };\n    this.holderRef = holderEl => {\n      if (holderEl === this.holderEl) {\n        return;\n      }\n      this.holderEl = holderEl;\n    };\n    this.wrapperRef = wrapperEl => {\n      if (wrapperEl === this.wrapperEl) {\n        return;\n      }\n      this.wrapperEl = wrapperEl;\n      this.updateScrollEl();\n      this.updateBoundaryEl();\n    };\n    this.checkPosition = () => {\n      const {\n        holderEl,\n        wrapperEl,\n        boundaryEl,\n        scrollEl,\n        disabled\n      } = this;\n      if (!scrollEl || !holderEl || !wrapperEl) {\n        console.error(\"Missing required elements:\", {\n          scrollEl,\n          holderEl,\n          wrapperEl\n        });\n        return;\n      }\n      const {\n        mode,\n        onFixedToggle,\n        offsetTransforms,\n        isIOSFixEnabled,\n        dontUpdateHolderHeightWhenSticky\n      } = this.props;\n      if (disabled) {\n        if (this.state.isFixed) {\n          this.setState({\n            isFixed: false,\n            wrapperStyles: {}\n          });\n        }\n        return;\n      }\n      if (!holderEl.getBoundingClientRect || !wrapperEl.getBoundingClientRect) {\n        return;\n      }\n      const holderRect = holderEl.getBoundingClientRect();\n      const wrapperRect = wrapperEl.getBoundingClientRect();\n      const boundaryRect = boundaryEl ? (0, rect_1.getRect)(boundaryEl) : rect_1.infiniteRect;\n      const scrollRect = (0, rect_1.getRect)(scrollEl);\n      const isFixed = this.isFixed(holderRect, wrapperRect, boundaryRect, scrollRect);\n      let offsets = null;\n      if (offsetTransforms && isFixed && scrollEl instanceof HTMLElement) {\n        const closestTransformedParent = (0, getClosestTransformedParent_1.default)(scrollEl);\n        if (closestTransformedParent) {\n          offsets = (0, rect_1.getRect)(closestTransformedParent);\n        }\n      }\n      const minHeight = this.state.isFixed && dontUpdateHolderHeightWhenSticky && this.lastMinHeight ? this.lastMinHeight : wrapperRect.height;\n      this.lastMinHeight = minHeight;\n      // To ensure that this component becomes sticky immediately on mobile devices instead\n      // of disappearing until the scroll event completes, we add `transform: translateZ(0)`\n      // to 'kick' rendering of this element to the GPU\n      // @see http://stackoverflow.com/questions/32875046\n      const iosRenderingFixStyles = isIOSFixEnabled ? {\n        transform: 'translateZ(0)',\n        WebkitTransform: 'translateZ(0)'\n      } : undefined;\n      const newState = {\n        isFixed,\n        height: wrapperRect.height,\n        holderStyles: {\n          minHeight: `${minHeight}px`\n        },\n        wrapperStyles: isFixed ? Object.assign(Object.assign({}, iosRenderingFixStyles), buildStickyStyle(mode, this.props, {\n          boundaryTop: mode === 'bottom' ? boundaryRect.top : 0,\n          boundaryBottom: mode === 'top' ? boundaryRect.bottom : 0,\n          top: mode === 'top' ? scrollRect.top - (offsets ? offsets.top : 0) : 0,\n          bottom: mode === 'bottom' ? scrollRect.bottom - (offsets ? offsets.bottom : 0) : 0,\n          width: holderRect.width,\n          height: wrapperRect.height\n        })) : iosRenderingFixStyles\n      };\n      if (isFixed !== this.state.isFixed && onFixedToggle && typeof onFixedToggle === 'function') {\n        onFixedToggle(isFixed);\n      }\n      if (!isEqual(this.state, newState)) {\n        this.setState(newState);\n      }\n    };\n  }\n  isFixed(holderRect, wrapperRect, boundaryRect, scrollRect) {\n    const {\n      hideOnBoundaryHit,\n      bottomOffset,\n      topOffset,\n      mode\n    } = this.props;\n    if (this.disabled) {\n      return false;\n    }\n    if (hideOnBoundaryHit && boundaryRect && !(0, rect_1.isIntersecting)(boundaryRect, scrollRect, topOffset, bottomOffset)) {\n      return false;\n    }\n    const hideOffset = hideOnBoundaryHit ? wrapperRect.height + bottomOffset : 0;\n    if (mode === 'top') {\n      return holderRect.top + topOffset < scrollRect.top && scrollRect.top + hideOffset <= boundaryRect.bottom;\n    }\n    return holderRect.bottom - topOffset > scrollRect.bottom && scrollRect.bottom - hideOffset >= boundaryRect.top;\n  }\n  updateScrollEl() {\n    if (!this.wrapperEl) {\n      return;\n    }\n    if (this.scrollEl) {\n      (0, events_1.unlisten)(this.scrollEl, ['scroll'], this.checkPosition);\n      this.scrollEl = null;\n    }\n    const {\n      scrollElement\n    } = this.props;\n    if (typeof scrollElement === 'string') {\n      this.scrollEl = (0, find_1.default)(scrollElement, this.wrapperEl);\n    } else {\n      this.scrollEl = scrollElement;\n    }\n    if (this.scrollEl) {\n      (0, events_1.listen)(this.scrollEl, ['scroll'], this.checkPosition);\n    } else {\n      console.error('Cannot find scrollElement ' + (typeof scrollElement === 'string' ? scrollElement : 'unknown'));\n    }\n  }\n  updateBoundaryEl() {\n    if (!this.wrapperEl) {\n      return;\n    }\n    const {\n      boundaryElement\n    } = this.props;\n    this.boundaryEl = (0, find_1.default)(boundaryElement, this.wrapperEl);\n    if (this.boundaryEl === window || this.boundaryEl === document) {\n      // such objects can't be used as boundary\n      // and in fact there is no point in such a case\n      this.boundaryEl = null;\n    }\n  }\n  initialize() {\n    const {\n      positionRecheckInterval,\n      disabled\n    } = this.props;\n    this.disabled = disabled;\n    // we should always listen to window events because they will affect the layout of the whole page\n    (0, events_1.listen)(window, ['scroll', 'resize', 'pageshow', 'load'], this.checkPosition);\n    this.checkPosition();\n    if (positionRecheckInterval) {\n      this.checkPositionIntervalId = setInterval(this.checkPosition, positionRecheckInterval);\n    }\n  }\n  componentDidUpdate(_ref) {\n    let {\n      scrollElement,\n      boundaryElement,\n      disabled\n    } = _ref;\n    if (scrollElement !== this.props.scrollElement || this.scrollEl === null) {\n      this.updateScrollEl();\n    }\n    if (boundaryElement !== this.props.boundaryElement || this.boundaryEl === null) {\n      this.updateBoundaryEl();\n    }\n    if (disabled !== this.props.disabled) {\n      this.disabled = this.props.disabled;\n      this.checkPosition();\n    }\n  }\n  componentDidMount() {\n    this.initialize();\n    if (this.wrapperEl === null) {\n      console.error(\"Wrapper element is missing, please make sure that you have assigned refs correctly\");\n    }\n  }\n  componentWillUnmount() {\n    if (this.scrollEl) {\n      (0, events_1.unlisten)(this.scrollEl, ['scroll'], this.checkPosition);\n    }\n    (0, events_1.unlisten)(window, ['scroll', 'resize', 'pageshow', 'load'], this.checkPosition);\n    this.boundaryEl = null;\n    this.scrollEl = null;\n    if (this.checkPositionIntervalId) {\n      clearInterval(this.checkPositionIntervalId);\n    }\n  }\n  render() {\n    const {\n      holderRef,\n      wrapperRef\n    } = this;\n    const {\n      isFixed,\n      wrapperStyles,\n      holderStyles\n    } = this.state;\n    return this.props.children({\n      holderRef,\n      wrapperRef,\n      isFixed,\n      wrapperStyles,\n      holderStyles\n    });\n  }\n}\nSticky.defaultProps = {\n  mode: 'top',\n  topOffset: 0,\n  bottomOffset: 0,\n  isIOSFixEnabled: true,\n  offsetTransforms: true,\n  disabled: false,\n  onFixedToggle: null,\n  boundaryElement: null,\n  hideOnBoundaryHit: true,\n  scrollElement: 'window',\n  dontUpdateHolderHeightWhenSticky: false\n};\nexports.default = Sticky;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","react_1","require","events_1","find_1","getClosestTransformedParent_1","rect_1","buildTopStyles","container","props","bottomOffset","hideOnBoundaryHit","top","height","width","boundaryBottom","position","bottom","buildBottomStyles","boundaryTop","buildStickyStyle","mode","isEqual","obj1","obj2","styles1","wrapperStyles","styles2","isFixed","field","hasOwnProperty","Sticky","Component","constructor","arguments","holderEl","wrapperEl","el","scrollEl","boundaryEl","disabled","checkPositionIntervalId","lastMinHeight","state","undefined","holderStyles","holderRef","wrapperRef","updateScrollEl","updateBoundaryEl","checkPosition","console","error","onFixedToggle","offsetTransforms","isIOSFixEnabled","dontUpdateHolderHeightWhenSticky","setState","getBoundingClientRect","holderRect","wrapperRect","boundaryRect","getRect","infiniteRect","scrollRect","offsets","HTMLElement","closestTransformedParent","default","minHeight","iosRenderingFixStyles","transform","WebkitTransform","newState","assign","topOffset","isIntersecting","hideOffset","unlisten","scrollElement","listen","boundaryElement","window","document","initialize","positionRecheckInterval","setInterval","componentDidUpdate","_ref","componentDidMount","componentWillUnmount","clearInterval","render","children","defaultProps"],"sources":["D:/react/website/finalcode/node_modules/react-sticky-el/lib/render-props-version.js"],"sourcesContent":["\"use strict\";\n// @flow strict\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_1 = require(\"react\");\nconst events_1 = require(\"./helpers/events\");\nconst find_1 = __importDefault(require(\"./helpers/find\"));\nconst getClosestTransformedParent_1 = __importDefault(require(\"./helpers/getClosestTransformedParent\"));\nconst rect_1 = require(\"./helpers/rect\");\nconst buildTopStyles = (container, props) => {\n    const { bottomOffset, hideOnBoundaryHit } = props;\n    const { top, height, width, boundaryBottom } = container;\n    // above boundary\n    if (hideOnBoundaryHit || (top + height + bottomOffset < boundaryBottom)) {\n        return { top: `${top}px`, width: `${width}px`, position: 'fixed' };\n    }\n    // reaching boundary\n    if (!hideOnBoundaryHit && boundaryBottom > 0) {\n        return { top: `${boundaryBottom - height - bottomOffset}px`, width: `${width}px`, position: 'fixed' };\n    }\n    // below boundary\n    return { width: `${width}px`, bottom: `${bottomOffset}px`, position: 'absolute' };\n};\nconst buildBottomStyles = (container, props) => {\n    const { bottomOffset, hideOnBoundaryHit } = props;\n    const { bottom, height, width, boundaryTop } = container;\n    if (hideOnBoundaryHit || (bottom - height - bottomOffset > boundaryTop)) {\n        return { width: `${width}px`, top: `${bottom - height}px`, position: 'fixed' };\n    }\n    return { width: `${width}px`, top: `${bottomOffset}px`, position: 'absolute' };\n};\nconst buildStickyStyle = (mode, props, container) => (mode === 'top' ? buildTopStyles : buildBottomStyles)(container, props);\nconst isEqual = (obj1, obj2) => {\n    const styles1 = obj1.wrapperStyles;\n    const styles2 = obj2.wrapperStyles;\n    if (obj1.isFixed !== obj2.isFixed ||\n        obj1.height !== obj2.height ||\n        (!styles1 && styles2) ||\n        (styles1 && !styles2)) {\n        return false;\n    }\n    if (!styles2) {\n        return true;\n    }\n    for (const field in styles1) {\n        // @ts-expect-error - ts doesn't like that `field` is a string\n        // eslint-disable-next-line no-prototype-builtins\n        if (styles1.hasOwnProperty(field) && styles1[field] !== styles2[field]) {\n            return false;\n        }\n    }\n    return true;\n};\nclass Sticky extends react_1.Component {\n    constructor() {\n        super(...arguments);\n        this.holderEl = null;\n        this.wrapperEl = null;\n        this.el = null;\n        this.scrollEl = null;\n        this.boundaryEl = null;\n        this.disabled = false;\n        this.checkPositionIntervalId = null;\n        this.lastMinHeight = null;\n        this.state = {\n            isFixed: false,\n            wrapperStyles: undefined,\n            holderStyles: undefined,\n            height: 0\n        };\n        this.holderRef = (holderEl) => {\n            if (holderEl === this.holderEl) {\n                return;\n            }\n            this.holderEl = holderEl;\n        };\n        this.wrapperRef = (wrapperEl) => {\n            if (wrapperEl === this.wrapperEl) {\n                return;\n            }\n            this.wrapperEl = wrapperEl;\n            this.updateScrollEl();\n            this.updateBoundaryEl();\n        };\n        this.checkPosition = () => {\n            const { holderEl, wrapperEl, boundaryEl, scrollEl, disabled } = this;\n            if (!scrollEl || !holderEl || !wrapperEl) {\n                console.error(\"Missing required elements:\", {\n                    scrollEl,\n                    holderEl,\n                    wrapperEl\n                });\n                return;\n            }\n            const { mode, onFixedToggle, offsetTransforms, isIOSFixEnabled, dontUpdateHolderHeightWhenSticky } = this.props;\n            if (disabled) {\n                if (this.state.isFixed) {\n                    this.setState({ isFixed: false, wrapperStyles: {} });\n                }\n                return;\n            }\n            if (!holderEl.getBoundingClientRect || !wrapperEl.getBoundingClientRect) {\n                return;\n            }\n            const holderRect = holderEl.getBoundingClientRect();\n            const wrapperRect = wrapperEl.getBoundingClientRect();\n            const boundaryRect = boundaryEl ? (0, rect_1.getRect)(boundaryEl) : rect_1.infiniteRect;\n            const scrollRect = (0, rect_1.getRect)(scrollEl);\n            const isFixed = this.isFixed(holderRect, wrapperRect, boundaryRect, scrollRect);\n            let offsets = null;\n            if (offsetTransforms && isFixed && scrollEl instanceof HTMLElement) {\n                const closestTransformedParent = (0, getClosestTransformedParent_1.default)(scrollEl);\n                if (closestTransformedParent) {\n                    offsets = (0, rect_1.getRect)(closestTransformedParent);\n                }\n            }\n            const minHeight = this.state.isFixed && dontUpdateHolderHeightWhenSticky && this.lastMinHeight ? this.lastMinHeight : wrapperRect.height;\n            this.lastMinHeight = minHeight;\n            // To ensure that this component becomes sticky immediately on mobile devices instead\n            // of disappearing until the scroll event completes, we add `transform: translateZ(0)`\n            // to 'kick' rendering of this element to the GPU\n            // @see http://stackoverflow.com/questions/32875046\n            const iosRenderingFixStyles = isIOSFixEnabled ? {\n                transform: 'translateZ(0)',\n                WebkitTransform: 'translateZ(0)'\n            } : undefined;\n            const newState = {\n                isFixed,\n                height: wrapperRect.height,\n                holderStyles: { minHeight: `${minHeight}px` },\n                wrapperStyles: isFixed ? Object.assign(Object.assign({}, iosRenderingFixStyles), buildStickyStyle(mode, this.props, {\n                    boundaryTop: mode === 'bottom' ? boundaryRect.top : 0,\n                    boundaryBottom: mode === 'top' ? boundaryRect.bottom : 0,\n                    top: mode === 'top' ? scrollRect.top - (offsets ? offsets.top : 0) : 0,\n                    bottom: mode === 'bottom' ? scrollRect.bottom - (offsets ? offsets.bottom : 0) : 0,\n                    width: holderRect.width,\n                    height: wrapperRect.height\n                })) : iosRenderingFixStyles\n            };\n            if (isFixed !== this.state.isFixed && onFixedToggle && typeof onFixedToggle === 'function') {\n                onFixedToggle(isFixed);\n            }\n            if (!isEqual(this.state, newState)) {\n                this.setState(newState);\n            }\n        };\n    }\n    isFixed(holderRect, wrapperRect, boundaryRect, scrollRect) {\n        const { hideOnBoundaryHit, bottomOffset, topOffset, mode } = this.props;\n        if (this.disabled) {\n            return false;\n        }\n        if (hideOnBoundaryHit && boundaryRect && !(0, rect_1.isIntersecting)(boundaryRect, scrollRect, topOffset, bottomOffset)) {\n            return false;\n        }\n        const hideOffset = hideOnBoundaryHit ? wrapperRect.height + bottomOffset : 0;\n        if (mode === 'top') {\n            return (holderRect.top + topOffset < scrollRect.top)\n                && (scrollRect.top + hideOffset <= boundaryRect.bottom);\n        }\n        return (holderRect.bottom - topOffset > scrollRect.bottom)\n            && (scrollRect.bottom - hideOffset >= boundaryRect.top);\n    }\n    updateScrollEl() {\n        if (!this.wrapperEl) {\n            return;\n        }\n        if (this.scrollEl) {\n            (0, events_1.unlisten)(this.scrollEl, ['scroll'], this.checkPosition);\n            this.scrollEl = null;\n        }\n        const { scrollElement } = this.props;\n        if (typeof scrollElement === 'string') {\n            this.scrollEl = (0, find_1.default)(scrollElement, this.wrapperEl);\n        }\n        else {\n            this.scrollEl = scrollElement;\n        }\n        if (this.scrollEl) {\n            (0, events_1.listen)(this.scrollEl, ['scroll'], this.checkPosition);\n        }\n        else {\n            console.error('Cannot find scrollElement ' + (typeof scrollElement === 'string' ? scrollElement : 'unknown'));\n        }\n    }\n    updateBoundaryEl() {\n        if (!this.wrapperEl) {\n            return;\n        }\n        const { boundaryElement } = this.props;\n        this.boundaryEl = (0, find_1.default)(boundaryElement, this.wrapperEl);\n        if (this.boundaryEl === window || this.boundaryEl === document) {\n            // such objects can't be used as boundary\n            // and in fact there is no point in such a case\n            this.boundaryEl = null;\n        }\n    }\n    initialize() {\n        const { positionRecheckInterval, disabled } = this.props;\n        this.disabled = disabled;\n        // we should always listen to window events because they will affect the layout of the whole page\n        (0, events_1.listen)(window, ['scroll', 'resize', 'pageshow', 'load'], this.checkPosition);\n        this.checkPosition();\n        if (positionRecheckInterval) {\n            this.checkPositionIntervalId = setInterval(this.checkPosition, positionRecheckInterval);\n        }\n    }\n    componentDidUpdate({ scrollElement, boundaryElement, disabled }) {\n        if (scrollElement !== this.props.scrollElement || this.scrollEl === null) {\n            this.updateScrollEl();\n        }\n        if (boundaryElement !== this.props.boundaryElement || this.boundaryEl === null) {\n            this.updateBoundaryEl();\n        }\n        if (disabled !== this.props.disabled) {\n            this.disabled = this.props.disabled;\n            this.checkPosition();\n        }\n    }\n    componentDidMount() {\n        this.initialize();\n        if (this.wrapperEl === null) {\n            console.error(\"Wrapper element is missing, please make sure that you have assigned refs correctly\");\n        }\n    }\n    componentWillUnmount() {\n        if (this.scrollEl) {\n            (0, events_1.unlisten)(this.scrollEl, ['scroll'], this.checkPosition);\n        }\n        (0, events_1.unlisten)(window, ['scroll', 'resize', 'pageshow', 'load'], this.checkPosition);\n        this.boundaryEl = null;\n        this.scrollEl = null;\n        if (this.checkPositionIntervalId) {\n            clearInterval(this.checkPositionIntervalId);\n        }\n    }\n    render() {\n        const { holderRef, wrapperRef } = this;\n        const { isFixed, wrapperStyles, holderStyles } = this.state;\n        return this.props.children({\n            holderRef,\n            wrapperRef,\n            isFixed,\n            wrapperStyles,\n            holderStyles\n        });\n    }\n}\nSticky.defaultProps = {\n    mode: 'top',\n    topOffset: 0,\n    bottomOffset: 0,\n    isIOSFixEnabled: true,\n    offsetTransforms: true,\n    disabled: false,\n    onFixedToggle: null,\n    boundaryElement: null,\n    hideOnBoundaryHit: true,\n    scrollElement: 'window',\n    dontUpdateHolderHeightWhenSticky: false,\n};\nexports.default = Sticky;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}